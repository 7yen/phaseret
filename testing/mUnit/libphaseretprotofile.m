function [methodinfo,structs,enuminfo,ThunkLibName]=libphaseretprotofile
%LIBPHASERETPROTOFILE Create structures to define interfaces found in 'phaseret'.

%This function was generated by loadlibrary.m parser version 1.1.6.38 on Thu Aug 18 20:23:25 2016
%perl options:'phaseret.i -outfile=libphaseretprotofile.m -thunkfile=libphaseret_thunk_glnxa64.c -header=phaseret.h'
ival={cell(1,0)}; % change 0 to the actual number of functions to preallocate the data.
structs=[];enuminfo=[];fcnNum=1;
fcns=struct('name',ival,'calltype',ival,'LHS',ival,'RHS',ival,'alias',ival,'thunkname', ival);
MfilePath=fileparts(mfilename('fullpath'));
ThunkLibName=fullfile(MfilePath,'libphaseret_thunk_glnxa64');
% int dgtreal_anasyn_init ( const double g [], int gl , int L , int W , int a , int M , _Complex double c [], dgtreal_anasyn_hint hint , ltfat_phaseconvention ptype , unsigned flags , dgtreal_anasyn_plan ** p ); 
fcns.thunkname{fcnNum}='int32voidPtrint32int32int32int32int32voidPtrdgtreal_anasyn_hintltfat_phaseconventionuint32voidPtrThunk';fcns.name{fcnNum}='dgtreal_anasyn_init'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'doublePtr', 'int32', 'int32', 'int32', 'int32', 'int32', 'voidPtr', 'dgtreal_anasyn_hint', 'ltfat_phaseconvention', 'uint32', 'dgtreal_anasyn_planPtrPtr'};fcnNum=fcnNum+1;
% int dgtreal_anasyn_execute_proj ( dgtreal_anasyn_plan * p , const _Complex double cin [], _Complex double cout []); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrvoidPtrThunk';fcns.name{fcnNum}='dgtreal_anasyn_execute_proj'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'dgtreal_anasyn_planPtr', 'voidPtr', 'voidPtr'};fcnNum=fcnNum+1;
% int dgtreal_anasyn_execute_syn ( dgtreal_anasyn_plan * p , const _Complex double c [], double f []); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrvoidPtrThunk';fcns.name{fcnNum}='dgtreal_anasyn_execute_syn'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'dgtreal_anasyn_planPtr', 'voidPtr', 'doublePtr'};fcnNum=fcnNum+1;
% int dgtreal_anasyn_execute_ana ( dgtreal_anasyn_plan * p , const double f [], _Complex double c []); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrvoidPtrThunk';fcns.name{fcnNum}='dgtreal_anasyn_execute_ana'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'dgtreal_anasyn_planPtr', 'doublePtr', 'voidPtr'};fcnNum=fcnNum+1;
% int dgtreal_anasyn_done ( dgtreal_anasyn_plan ** p ); 
fcns.thunkname{fcnNum}='int32voidPtrThunk';fcns.name{fcnNum}='dgtreal_anasyn_done'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'dgtreal_anasyn_planPtrPtr'};fcnNum=fcnNum+1;
% int gla ( const _Complex double cinit [], const double g [], const int L , const int gl , const int W , const int a , const int M , const int iter , _Complex double cout []); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrint32int32int32int32int32int32voidPtrThunk';fcns.name{fcnNum}='gla'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'doublePtr', 'int32', 'int32', 'int32', 'int32', 'int32', 'int32', 'voidPtr'};fcnNum=fcnNum+1;
% int gla_init ( const _Complex double cinit [], const double g [], const int L , const int gl , const int W , const int a , const int M , const double alpha , _Complex double c [], dgtreal_anasyn_hint hint , unsigned flags , gla_plan ** p ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrint32int32int32int32int32doublevoidPtrdgtreal_anasyn_hintuint32voidPtrThunk';fcns.name{fcnNum}='gla_init'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'doublePtr', 'int32', 'int32', 'int32', 'int32', 'int32', 'double', 'voidPtr', 'dgtreal_anasyn_hint', 'uint32', 'gla_planPtrPtr'};fcnNum=fcnNum+1;
% int gla_execute ( gla_plan * p , const int iter ); 
fcns.thunkname{fcnNum}='int32voidPtrint32Thunk';fcns.name{fcnNum}='gla_execute'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'gla_planPtr', 'int32'};fcnNum=fcnNum+1;
% int gla_execute_newarray ( gla_plan * p , const _Complex double cinit [], const int iter , _Complex double cout []); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrint32voidPtrThunk';fcns.name{fcnNum}='gla_execute_newarray'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'gla_planPtr', 'voidPtr', 'int32', 'voidPtr'};fcnNum=fcnNum+1;
% int gla_done ( gla_plan ** p ); 
fcns.thunkname{fcnNum}='int32voidPtrThunk';fcns.name{fcnNum}='gla_done'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'gla_planPtrPtr'};fcnNum=fcnNum+1;
% int gla_set_status_callback ( gla_plan * p , gla_callback_status * callback , void * userdata ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrvoidPtrThunk';fcns.name{fcnNum}='gla_set_status_callback'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'gla_planPtr', 'FcnPtrPtr', 'voidPtr'};fcnNum=fcnNum+1;
% int gla_set_cmod_callback ( gla_plan * p , gla_callback_cmod * callback , void * userdata ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrvoidPtrThunk';fcns.name{fcnNum}='gla_set_cmod_callback'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'gla_planPtr', 'FcnPtrPtr', 'voidPtr'};fcnNum=fcnNum+1;
% int gla_set_fmod_callback ( gla_plan * p , gla_callback_fmod * callback , void * userdata ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrvoidPtrThunk';fcns.name{fcnNum}='gla_set_fmod_callback'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'gla_planPtr', 'FcnPtrPtr', 'voidPtr'};fcnNum=fcnNum+1;
% int fastupdate ( _Complex double * c , _Complex double * t , double alpha , int L ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrdoubleint32Thunk';fcns.name{fcnNum}='fastupdate'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'voidPtr', 'double', 'int32'};fcnNum=fcnNum+1;
% void overlaynthframe ( const double * frames , int gl , int N , int a , int n , double * frame ); 
fcns.thunkname{fcnNum}='voidvoidPtrint32int32int32int32voidPtrThunk';fcns.name{fcnNum}='overlaynthframe'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'doublePtr', 'int32', 'int32', 'int32', 'int32', 'doublePtr'};fcnNum=fcnNum+1;
% void rtisilaoverlaynthframe ( rtisilaupdate_plan * p , const double * frames , const double * g , int n , int N ); 
fcns.thunkname{fcnNum}='voidvoidPtrvoidPtrvoidPtrint32int32Thunk';fcns.name{fcnNum}='rtisilaoverlaynthframe'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'rtisilaupdate_planPtr', 'doublePtr', 'doublePtr', 'int32', 'int32'};fcnNum=fcnNum+1;
% void rtisilaphaseupdate ( rtisilaupdate_plan * p , const double * sframe , double * frameupd , fftw_complex * c ); 
fcns.thunkname{fcnNum}='voidvoidPtrvoidPtrvoidPtrvoidPtrThunk';fcns.name{fcnNum}='rtisilaphaseupdate'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'rtisilaupdate_planPtr', 'doublePtr', 'doublePtr', 'errorPtr'};fcnNum=fcnNum+1;
% int rtisilaupdate_init ( const double * g , const double * specg1 , const double * specg2 , const double * gd , const int gl , int a , int M , rtisilaupdate_plan ** p ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrvoidPtrvoidPtrint32int32int32voidPtrThunk';fcns.name{fcnNum}='rtisilaupdate_init'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'doublePtr', 'doublePtr', 'doublePtr', 'doublePtr', 'int32', 'int32', 'int32', 'rtisilaupdate_planPtrPtr'};fcnNum=fcnNum+1;
% int rtisilaupdate_done ( rtisilaupdate_plan ** p ); 
fcns.thunkname{fcnNum}='int32voidPtrThunk';fcns.name{fcnNum}='rtisilaupdate_done'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'rtisilaupdate_planPtrPtr'};fcnNum=fcnNum+1;
% void rtisilaupdate_execute ( rtisilaupdate_plan * p , const double * frames , int N , const double * s , int lookahead , int maxit , double * frames2 , fftw_complex * c ); 
fcns.thunkname{fcnNum}='voidvoidPtrvoidPtrint32voidPtrint32int32voidPtrvoidPtrThunk';fcns.name{fcnNum}='rtisilaupdate_execute'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'rtisilaupdate_planPtr', 'doublePtr', 'int32', 'doublePtr', 'int32', 'int32', 'doublePtr', 'errorPtr'};fcnNum=fcnNum+1;
% void rtisilaupdate ( const double * frames , const double * g , const double * specg1 , const double * specg2 , const double * gd , const int gl , int a , int M , int N , const double * s , int lookahead , int maxit , double * frames2 ); 
fcns.thunkname{fcnNum}='voidvoidPtrvoidPtrvoidPtrvoidPtrvoidPtrint32int32int32int32voidPtrint32int32voidPtrThunk';fcns.name{fcnNum}='rtisilaupdate'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'doublePtr', 'doublePtr', 'doublePtr', 'doublePtr', 'doublePtr', 'int32', 'int32', 'int32', 'int32', 'doublePtr', 'int32', 'int32', 'doublePtr'};fcnNum=fcnNum+1;
% int rtisila_init ( const double g [], const int gl , const int W , int a , int M , int lookahead , int maxit , rtisila_state ** p ); 
fcns.thunkname{fcnNum}='int32voidPtrint32int32int32int32int32int32voidPtrThunk';fcns.name{fcnNum}='rtisila_init'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'doublePtr', 'int32', 'int32', 'int32', 'int32', 'int32', 'int32', 'rtisila_statePtrPtr'};fcnNum=fcnNum+1;
% int rtisila_init_win ( LTFAT_FIRWIN win , int gl , int W , int a , int M , int lookahead , int maxit , rtisila_state ** p ); 
fcns.thunkname{fcnNum}='int32LTFAT_FIRWINint32int32int32int32int32int32voidPtrThunk';fcns.name{fcnNum}='rtisila_init_win'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'LTFAT_FIRWIN', 'int32', 'int32', 'int32', 'int32', 'int32', 'int32', 'rtisila_statePtrPtr'};fcnNum=fcnNum+1;
% int rtisila_set_lookahead ( rtisila_state * p , int lookahead ); 
fcns.thunkname{fcnNum}='int32voidPtrint32Thunk';fcns.name{fcnNum}='rtisila_set_lookahead'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'rtisila_statePtr', 'int32'};fcnNum=fcnNum+1;
% int rtisila_execute ( rtisila_state * p , const double s [], double _Complex c []); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrvoidPtrThunk';fcns.name{fcnNum}='rtisila_execute'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'rtisila_statePtr', 'doublePtr', 'voidPtr'};fcnNum=fcnNum+1;
% int rtisila_reset ( rtisila_state * p ); 
fcns.thunkname{fcnNum}='int32voidPtrThunk';fcns.name{fcnNum}='rtisila_reset'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'rtisila_statePtr'};fcnNum=fcnNum+1;
% int rtisila_done ( rtisila_state ** p ); 
fcns.thunkname{fcnNum}='int32voidPtrThunk';fcns.name{fcnNum}='rtisila_done'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'rtisila_statePtrPtr'};fcnNum=fcnNum+1;
% int rtisilaoffline ( const double s [], const double g [], int L , int gl , int W , int a , int M , int lookahead , int maxit , _Complex double c []); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrint32int32int32int32int32int32int32voidPtrThunk';fcns.name{fcnNum}='rtisilaoffline'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'doublePtr', 'doublePtr', 'int32', 'int32', 'int32', 'int32', 'int32', 'int32', 'int32', 'voidPtr'};fcnNum=fcnNum+1;
% int legla_init_params_defaults ( legla_init_params * params ); 
fcns.thunkname{fcnNum}='int32voidPtrThunk';fcns.name{fcnNum}='legla_init_params_defaults'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'legla_init_paramsPtr'};fcnNum=fcnNum+1;
% int legla ( const _Complex double cinit [], const double g [], const int L , const int gl , const int W , const int a , const int M , const int iter , _Complex double cout []); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrint32int32int32int32int32int32voidPtrThunk';fcns.name{fcnNum}='legla'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'doublePtr', 'int32', 'int32', 'int32', 'int32', 'int32', 'int32', 'voidPtr'};fcnNum=fcnNum+1;
% int legla_init ( const _Complex double cinit [], const double g [], const int L , const int gl , const int W , const int a , const int M , const double alpha , _Complex double c [], legla_init_params * params , legla_plan ** pout ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrint32int32int32int32int32doublevoidPtrvoidPtrvoidPtrThunk';fcns.name{fcnNum}='legla_init'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'doublePtr', 'int32', 'int32', 'int32', 'int32', 'int32', 'double', 'voidPtr', 'legla_init_paramsPtr', 'legla_planPtrPtr'};fcnNum=fcnNum+1;
% int legla_execute ( legla_plan * p , const int iter ); 
fcns.thunkname{fcnNum}='int32voidPtrint32Thunk';fcns.name{fcnNum}='legla_execute'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'legla_planPtr', 'int32'};fcnNum=fcnNum+1;
% int legla_execute_newarray ( legla_plan * p , const _Complex double cinit [], const int iter , _Complex double cout []); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrint32voidPtrThunk';fcns.name{fcnNum}='legla_execute_newarray'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'legla_planPtr', 'voidPtr', 'int32', 'voidPtr'};fcnNum=fcnNum+1;
% int legla_done ( legla_plan ** p ); 
fcns.thunkname{fcnNum}='int32voidPtrThunk';fcns.name{fcnNum}='legla_done'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'legla_planPtrPtr'};fcnNum=fcnNum+1;
% int legla_set_status_callback ( legla_plan * p , legla_callback_status * callback , void * userdata ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrvoidPtrThunk';fcns.name{fcnNum}='legla_set_status_callback'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'legla_planPtr', 'FcnPtrPtr', 'voidPtr'};fcnNum=fcnNum+1;
% int legla_set_cmod_callback ( legla_plan * p , legla_callback_cmod * callback , void * userdata ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrvoidPtrThunk';fcns.name{fcnNum}='legla_set_cmod_callback'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'legla_planPtr', 'FcnPtrPtr', 'voidPtr'};fcnNum=fcnNum+1;
% int leglaupdate_init ( const _Complex double kern [], phaseret_size ksize , int L , int W , int a , int M , int flags , leglaupdate_plan ** pout ); 
fcns.thunkname{fcnNum}='int32voidPtrphaseret_sizeint32int32int32int32int32voidPtrThunk';fcns.name{fcnNum}='leglaupdate_init'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'phaseret_size', 'int32', 'int32', 'int32', 'int32', 'int32', 'leglaupdate_planPtrPtr'};fcnNum=fcnNum+1;
% extern void leglaupdate_execute ( leglaupdate_plan * plan , const double s [], _Complex double c [], _Complex double cout []); 
fcns.thunkname{fcnNum}='voidvoidPtrvoidPtrvoidPtrvoidPtrThunk';fcns.name{fcnNum}='leglaupdate_execute'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'leglaupdate_planPtr', 'doublePtr', 'voidPtr', 'voidPtr'};fcnNum=fcnNum+1;
% void leglaupdate_done ( leglaupdate_plan ** plan ); 
fcns.thunkname{fcnNum}='voidvoidPtrThunk';fcns.name{fcnNum}='leglaupdate_done'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'leglaupdate_planPtrPtr'};fcnNum=fcnNum+1;
% int leglaupdate_init_col ( int M , phaseret_size ksize , int flags , leglaupdate_plan_col ** pout ); 
fcns.thunkname{fcnNum}='int32int32phaseret_sizeint32voidPtrThunk';fcns.name{fcnNum}='leglaupdate_init_col'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32', 'phaseret_size', 'int32', 'leglaupdate_plan_colPtrPtr'};fcnNum=fcnNum+1;
% void leglaupdatereal_execute_col ( leglaupdate_plan_col * plan , const double sCol [], const _Complex double actK [], _Complex double cColFirst [], _Complex double coutrCol []); 
fcns.thunkname{fcnNum}='voidvoidPtrvoidPtrvoidPtrvoidPtrvoidPtrThunk';fcns.name{fcnNum}='leglaupdatereal_execute_col'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'leglaupdate_plan_colPtr', 'doublePtr', 'voidPtr', 'voidPtr', 'voidPtr'};fcnNum=fcnNum+1;
% void extendborders ( leglaupdate_plan_col * plan , const _Complex double c [], int N , _Complex double buf []); 
fcns.thunkname{fcnNum}='voidvoidPtrvoidPtrint32voidPtrThunk';fcns.name{fcnNum}='extendborders'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'leglaupdate_plan_colPtr', 'voidPtr', 'int32', 'voidPtr'};fcnNum=fcnNum+1;
% int legla_big2small_kernel ( _Complex double * bigc , phaseret_size bigsize , phaseret_size smallsize , _Complex double * smallc ); 
fcns.thunkname{fcnNum}='int32voidPtrphaseret_sizephaseret_sizevoidPtrThunk';fcns.name{fcnNum}='legla_big2small_kernel'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'phaseret_size', 'phaseret_size', 'voidPtr'};fcnNum=fcnNum+1;
% int legla_findkernelsize ( _Complex double * bigc , phaseret_size bigsize , double relthr , phaseret_size * ksize ); 
fcns.thunkname{fcnNum}='int32voidPtrphaseret_sizedoublevoidPtrThunk';fcns.name{fcnNum}='legla_findkernelsize'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'phaseret_size', 'double', 'phaseret_sizePtr'};fcnNum=fcnNum+1;
% void kernphasefi ( const _Complex double kern [], phaseret_size ksize , int n , int a , int M , _Complex double kernmod []); 
fcns.thunkname{fcnNum}='voidvoidPtrphaseret_sizeint32int32int32voidPtrThunk';fcns.name{fcnNum}='kernphasefi'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'voidPtr', 'phaseret_size', 'int32', 'int32', 'int32', 'voidPtr'};fcnNum=fcnNum+1;
% void formatkernel ( double * kernr , double * kerni , int kernh , int kernw , int kernwskip , double * kernmodr , double * kernmodi ); 
fcns.thunkname{fcnNum}='voidvoidPtrvoidPtrint32int32int32voidPtrvoidPtrThunk';fcns.name{fcnNum}='formatkernel'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'doublePtr', 'doublePtr', 'int32', 'int32', 'int32', 'doublePtr', 'doublePtr'};fcnNum=fcnNum+1;
% int phaseret_gcd ( int m , int n ); 
fcns.thunkname{fcnNum}='int32int32int32Thunk';fcns.name{fcnNum}='phaseret_gcd'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32', 'int32'};fcnNum=fcnNum+1;
% int phaseret_lcm ( int m , int n ); 
fcns.thunkname{fcnNum}='int32int32int32Thunk';fcns.name{fcnNum}='phaseret_lcm'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32', 'int32'};fcnNum=fcnNum+1;
% void spsi ( const double * s , int a , int M , int N , double * initphase , _Complex double * c ); 
fcns.thunkname{fcnNum}='voidvoidPtrint32int32int32voidPtrvoidPtrThunk';fcns.name{fcnNum}='spsi'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'doublePtr', 'int32', 'int32', 'int32', 'doublePtr', 'voidPtr'};fcnNum=fcnNum+1;
% void maskedspsi ( const double * s , int a , int M , int N , const double * mask , const double * phase , double * initphase , _Complex double * c ); 
fcns.thunkname{fcnNum}='voidvoidPtrint32int32int32voidPtrvoidPtrvoidPtrvoidPtrThunk';fcns.name{fcnNum}='maskedspsi'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'doublePtr', 'int32', 'int32', 'int32', 'doublePtr', 'doublePtr', 'doublePtr', 'voidPtr'};fcnNum=fcnNum+1;
% void spsiupdate ( const double * scol , int a , int M , double * tmpphase ); 
fcns.thunkname{fcnNum}='voidvoidPtrint32int32voidPtrThunk';fcns.name{fcnNum}='spsiupdate'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'doublePtr', 'int32', 'int32', 'doublePtr'};fcnNum=fcnNum+1;
% int shiftcolsleft ( double * cols , int height , int N , const double * newcol ); 
fcns.thunkname{fcnNum}='int32voidPtrint32int32voidPtrThunk';fcns.name{fcnNum}='shiftcolsleft'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'doublePtr', 'int32', 'int32', 'doublePtr'};fcnNum=fcnNum+1;
% int force_magnitude ( _Complex double * cin , const double * s , int L , _Complex double * cout ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrint32voidPtrThunk';fcns.name{fcnNum}='force_magnitude'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'doublePtr', 'int32', 'voidPtr'};fcnNum=fcnNum+1;
% int rtpghi_init ( double gamma , int W , int a , int M , double tol , int do_causal , rtpghi_state ** p ); 
fcns.thunkname{fcnNum}='int32doubleint32int32int32doubleint32voidPtrThunk';fcns.name{fcnNum}='rtpghi_init'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'double', 'int32', 'int32', 'int32', 'double', 'int32', 'rtpghi_statePtrPtr'};fcnNum=fcnNum+1;
% int rtpghi_set_causal ( rtpghi_state * p , int do_causal ); 
fcns.thunkname{fcnNum}='int32voidPtrint32Thunk';fcns.name{fcnNum}='rtpghi_set_causal'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'rtpghi_statePtr', 'int32'};fcnNum=fcnNum+1;
% int rtpghi_execute ( rtpghi_state * p , const double s [], _Complex double c []); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrvoidPtrThunk';fcns.name{fcnNum}='rtpghi_execute'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'rtpghi_statePtr', 'doublePtr', 'voidPtr'};fcnNum=fcnNum+1;
% int rtpghi_done ( rtpghi_state ** p ); 
fcns.thunkname{fcnNum}='int32voidPtrThunk';fcns.name{fcnNum}='rtpghi_done'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'rtpghi_statePtrPtr'};fcnNum=fcnNum+1;
% int rtpghioffline ( const double s [], double gamma , int L , int W , int a , int M , double tol , int do_causal , _Complex double c []); 
fcns.thunkname{fcnNum}='int32voidPtrdoubleint32int32int32int32doubleint32voidPtrThunk';fcns.name{fcnNum}='rtpghioffline'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'doublePtr', 'double', 'int32', 'int32', 'int32', 'int32', 'double', 'int32', 'voidPtr'};fcnNum=fcnNum+1;
% double firwin2gamma ( LTFAT_FIRWIN win , int gl ); 
fcns.thunkname{fcnNum}='doubleLTFAT_FIRWINint32Thunk';fcns.name{fcnNum}='firwin2gamma'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='double'; fcns.RHS{fcnNum}={'LTFAT_FIRWIN', 'int32'};fcnNum=fcnNum+1;
% void rtpghifgrad ( const double logs [], int a , int M , double gamma , int do_causal , double fgrad []); 
fcns.thunkname{fcnNum}='voidvoidPtrint32int32doubleint32voidPtrThunk';fcns.name{fcnNum}='rtpghifgrad'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'doublePtr', 'int32', 'int32', 'double', 'int32', 'doublePtr'};fcnNum=fcnNum+1;
% void rtpghitgrad ( const double logs [], int a , int M , double gamma , double tgrad []); 
fcns.thunkname{fcnNum}='voidvoidPtrint32int32doublevoidPtrThunk';fcns.name{fcnNum}='rtpghitgrad'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'doublePtr', 'int32', 'int32', 'double', 'doublePtr'};fcnNum=fcnNum+1;
% void rtpghilog ( const double in [], int L , double out []); 
fcns.thunkname{fcnNum}='voidvoidPtrint32voidPtrThunk';fcns.name{fcnNum}='rtpghilog'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'doublePtr', 'int32', 'doublePtr'};fcnNum=fcnNum+1;
% void rtpghimagphase ( const double s [], const double phase [], int L , _Complex double c []); 
fcns.thunkname{fcnNum}='voidvoidPtrvoidPtrint32voidPtrThunk';fcns.name{fcnNum}='rtpghimagphase'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'doublePtr', 'doublePtr', 'int32', 'voidPtr'};fcnNum=fcnNum+1;
% int pghi ( const double s [], double gamma , const int L , const int W , const int a , const int M , _Complex double c []); 
fcns.thunkname{fcnNum}='int32voidPtrdoubleint32int32int32int32voidPtrThunk';fcns.name{fcnNum}='pghi'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'doublePtr', 'double', 'int32', 'int32', 'int32', 'int32', 'voidPtr'};fcnNum=fcnNum+1;
% int pghi_withmask ( const _Complex double cin [], const int mask [], double gamma , const int L , const int W , const int a , const int M , _Complex double c []); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrdoubleint32int32int32int32voidPtrThunk';fcns.name{fcnNum}='pghi_withmask'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'int32Ptr', 'double', 'int32', 'int32', 'int32', 'int32', 'voidPtr'};fcnNum=fcnNum+1;
% int pghi_init ( double gamma , const int L , const int W , const int a , const int M , double tol1 , double tol2 , pghi_plan ** p ); 
fcns.thunkname{fcnNum}='int32doubleint32int32int32int32doubledoublevoidPtrThunk';fcns.name{fcnNum}='pghi_init'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'double', 'int32', 'int32', 'int32', 'int32', 'double', 'double', 'pghi_planPtrPtr'};fcnNum=fcnNum+1;
% int pghi_execute ( pghi_plan * p , const double s [], _Complex double c []); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrvoidPtrThunk';fcns.name{fcnNum}='pghi_execute'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'pghi_planPtr', 'doublePtr', 'voidPtr'};fcnNum=fcnNum+1;
% int pghi_execute_withmask ( pghi_plan * p , const _Complex double cin [], const int mask [], double buffer [], _Complex double cout []); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrvoidPtrvoidPtrvoidPtrThunk';fcns.name{fcnNum}='pghi_execute_withmask'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'pghi_planPtr', 'voidPtr', 'int32Ptr', 'doublePtr', 'voidPtr'};fcnNum=fcnNum+1;
% int pghi_done ( pghi_plan ** p ); 
fcns.thunkname{fcnNum}='int32voidPtrThunk';fcns.name{fcnNum}='pghi_done'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'pghi_planPtrPtr'};fcnNum=fcnNum+1;
% void pghimagphase ( const double s [], const double phase [], int L , _Complex double c []); 
fcns.thunkname{fcnNum}='voidvoidPtrvoidPtrint32voidPtrThunk';fcns.name{fcnNum}='pghimagphase'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'doublePtr', 'doublePtr', 'int32', 'voidPtr'};fcnNum=fcnNum+1;
% void pghilog ( const double in [], int L , double out []); 
fcns.thunkname{fcnNum}='voidvoidPtrint32voidPtrThunk';fcns.name{fcnNum}='pghilog'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'doublePtr', 'int32', 'doublePtr'};fcnNum=fcnNum+1;
% void pghitgrad ( const double logs [], double gamma , int a , int M , int N , double tgrad []); 
fcns.thunkname{fcnNum}='voidvoidPtrdoubleint32int32int32voidPtrThunk';fcns.name{fcnNum}='pghitgrad'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'doublePtr', 'double', 'int32', 'int32', 'int32', 'doublePtr'};fcnNum=fcnNum+1;
% void pghifgrad ( const double logs [], double gamma , int a , int M , int N , double fgrad []); 
fcns.thunkname{fcnNum}='voidvoidPtrdoubleint32int32int32voidPtrThunk';fcns.name{fcnNum}='pghifgrad'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'doublePtr', 'double', 'int32', 'int32', 'int32', 'doublePtr'};fcnNum=fcnNum+1;
structs.dgtreal_anasyn_plan.members=struct('');
structs.gla_plan.members=struct('');
structs.rtisilaupdate_plan.members=struct('');
structs.rtisila_state.members=struct('');
structs.legla_plan.members=struct('');
structs.leglaupdate_plan.members=struct('');
structs.leglaupdate_plan_col.members=struct('');
structs.phaseret_size.members=struct('height', 'int32', 'width', 'int32');
structs.phaseret_point.members=struct('y', 'int32', 'x', 'int32');
structs.legla_init_params.members=struct('relthr', 'double', 'ksize', 'phaseret_size', 'hint', 'dgtreal_anasyn_hint', 'dgtrealflags', 'uint32', 'leglaflags', 'uint32', 'private_hash_do_not_use', 'uint32');
structs.rtpghi_state.members=struct('');
structs.pghi_plan.members=struct('');
enuminfo.leglaupdate_mod=struct('MOD_STEPWISE',1,'MOD_FRAMEWISE',2,'MOD_COEFFICIENTWISE',4,'MOD_COEFFICIENTWISE_SORTED',8,'MOD_MODIFIEDUPDATE',16);
enuminfo.LTFAT_FIRWIN=struct('LTFAT_HANN',0,'LTFAT_HANNING',1,'LTFAT_NUTTALL10',2,'LTFAT_SQRTHANN',3,'LTFAT_COSINE',4,'LTFAT_SINE',5,'LTFAT_HAMMING',6,'LTFAT_NUTTALL01',7,'LTFAT_SQUARE',8,'LTFAT_RECT',9,'LTFAT_TRIA',10,'LTFAT_TRIANGULAR',11,'LTFAT_BARTLETT',12,'LTFAT_SQRTTRIA',13,'LTFAT_BLACKMAN',14,'LTFAT_BLACKMAN2',15,'LTFAT_NUTTALL',16,'LTFAT_NUTTALL12',17,'LTFAT_OGG',18,'LTFAT_ITERSINE',19,'LTFAT_NUTTALL20',20,'LTFAT_NUTTALL11',21,'LTFAT_NUTTALL02',22,'LTFAT_NUTTALL30',23,'LTFAT_NUTTALL21',24,'LTFAT_NUTTALL03',25);
enuminfo.leglaupdate_ext=struct('EXT_BOTH',1048576,'EXT_UPDOWN',2097152);
enuminfo.leglaupdate_frameorder=struct('ORDER_FWD',1024,'ORDER_REV',2048);
enuminfo.ltfat_phaseconvention=struct('LTFAT_FREQINV',0,'LTFAT_TIMEINV',1);
enuminfo.dgtreal_anasyn_hint=struct('dgtreal_anasyn_auto',0,'dgtreal_anasyn_long',1,'dgtreal_anasyn_fb',2);
methodinfo=fcns;